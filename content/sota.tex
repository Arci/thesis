\section{Introduction}
In this chapter, in section \ref{sec:nosql}, NoSQL databases are firstly introduced and compared with SQL solutions. In section \ref{sec:common-language} are listed some of the solution that has been developed in defining a common language or interface to interact with different NoSQL databases.

\noindent In section \ref{sec:jpa} is described the JPA interface and JPQL the query language used for JPA queries. In section \ref{sec:cpim} the CPIM library is introduced as a tentative in defining a common interface to interacts with different vendors in a PaaS environment, which include accessing their NoSQL solution.

\section{NoSQL databases}
\label{sec:nosql}
 some concerns have recently emerged towards RDBMSs. First, it has been argued that there are cases where their performances are not adequate, while dedicated engines, tailored for specific requirements (for example decision support or stream processing) behave much better [12] and provide scalabil- ity [11]. Second, the structure of the relational model, while being effective for many traditional applications, is considered to be too rigid or not useful in other cases, with arguments that call for semistructured data 
 
 At the same time, the full power of relational databases, with complex transactions and complex queries, is not needed in some contexts, where “simple operations” (reads and writes that involve small amount of data) are enough [11]. Also, in some cases, ACID consistency, the complete form of consistency guaranteed by RDBMSs, is not essential, and can be sacrificed for the sake of efficiency. It is worth observing that many Internet application domains, for example, the social networking domain, require both scalability (indeed, Web-size scalability) and flexibility in structure, while being satisfied with simple operations and weak forms of consistency.

With these motivations, a number of new systems, not following the RDBMS paradigm (neither in the interface nor in the implementation), have recently been developed. Their common features are scalability and support to simple operations only (and so, limited support to complex ones), with some flexibility in the structure of data. Most of them also relax consistency requirements. They are often indicated as NoSQL systems, because they can be accessed by APIs that offer much simpler operations than those that can be expressed in SQL. Probably, it would be more appropriate to call them non-relational, but we will stick to common usage and adopt the term NoSQL.

Relational database management systems have been around for more than thirty years. During this time, several revolutions (such as the Object Oriented database movement) have erupted, many of which threatened to doom SQL and relational databases. These revolutions eventually fizzled out, and none made even a small dent in the domi- nance of relational databases. The latest revolu- tion appears to be from NoSQL databases that are touted to be non-relational, horizontally scalable, distributed and, for the most part, open source

The debate on SQL vs. NoSQL is as much a debate on SQL, the language, as on the relational model and its various implementations.

There is a variety of systems in the NoSQL arena [6, 11], more than fifty, and each of them exposes a different interface (different model and different API).


The relational model and SQL were invented at a time when data management targeted primarily administrative applications. However, the data management landscape has evolved, and today’s landscape of data management applications is much more diverse than it was when the relational model and SQL were born

Thus, while relational database systems were first proposed as a way to store and manage struc- tured data, burgeoning NoSQL databases have emerged as a way to store unstructured data and other complex objects such as documents, data streams, and graphs. With the rise of the real-time web, NoSQL databases were designed to deal with very large volumes of data.

in spite of the research and develop- ment, the relational model and SQL may not be the best foundation for managing every new kind of data and workload.
The current standard, SQL:2011, is very complex With each addition, its body grows, and it becomes less stable.

\subsection{NoSQL characteristics}
While preserving ACID properties may not be as important for databases that typically contain append only data, they are absolutely essential for most operational systems and online transaction processing systems, including retail, banking, and finance.

NoSQL databases must cope with the CAP or Brewer’s Theorem which states that given the properties of consistency, availability and partition tolerance, a distributed computer system can satisfy up to two of those at the same time.
Consistency: a distributed system is said to be consistent if every node sees the same data at the same time.
Availability: means that the system is designed to keep working even if a failure to some nodes happens.
Partition tolerance: implies the ability of the system (divided in two or more partitions) to continue its work even if these partitions cannot communicate with each other.


All datastores marked as NoSQL are characterized by these particular features:
Horizontal Scalability: it is the ability of a system (a database) to handle a growing (or decreasing) amount of work in a capable and user-transparent way. This property is achieved thanks to the possibility of "sharding" the data, or better to split horizontally the data in a database. This function allows to access smaller pieces of data in a faster and easily managed way and allows the system to add or delete nodes from the datastore, without changing its structure and without a loss of performances in reads or writes. The main problem that this feature break out is that Join operations become very complex and inefficient.
Fault tolerance: when the amount of data increases, the datastore is able to recover after single or multiple failures. To do that, all NoSQL datastores provide data replication, storing different copies of the same piece of data; when a single replica is lost, the datastore can use its copies and it does not lose any information.
High availability: each data stored in a NoSQL database has to be reachable in a very limited time; like fault tolerance, this features is provided thanks to data replication. When the client asks the datastore for some data, the system answers with the nearest copy of the data requested, reducing time needed to answer and allowing multiple simultaneous answers to different clients, also when their number increases in a small time period.
Distributed and cloud oriented: NoSQL databases are based on a distributed infrastructure, distributing data on different nodes that can be managed in a very elastic way.
This kind of configuration permits to be more efficient and have better performances, distributing the workload on each node and not collect it on a single central node.
Flexible data schema (or schema-free): in contrast with traditional
RDBMS, the new NoSQL datastores have not a fixed data schema.
Unlike RDBMS fixed table structures, in this kind of systems different types of data can be stored. Due to this property, they are defined free-schema databases.

\subsection{NoSQL classification}
In the last few years CITE NOSQL.ORG a lot of new NoSQL databases have been devel- oped. Each of them tries to fit several requirements differently. 

Key/Value stores Key/Value stores are similar to data-structures like Maps or Hashtables, since they permit to retrieve information (values) given their key.

Column-oriented databases  Data are stored inside structures named Columns, which in turn are contained inside Column Families, and are indexed by Key. Typically, data inside the same Column (for every Key) are persisted together.

Document-oriented databases Document databases are mainly used to store semi-structured data which are called Documents. Each document may contain several unique ID fields, used to index other fields that can be of any type, simple or nested, including other documents. Typical documents formats are: JSON, BSON, YAML or XML.
This kind of databases allows to express queries over fields contained in the document.

Graph databases Graph databases are based on graphs theory and are typically used to represent highly interconnected data. Information are stored inside graphs; a node is the entity under consideration and its information is stored inside the so called properties (key/value pairs). It is possible to express relationships between nodes by means of edges.

Dire che esistono soluzioni ibride come OrientDB che è sia graph che document.

\subsection{Lack of a standard language}
it has been recently pointed out, the lack of standard is a great concern for organizations interested in adopting any of these systems [10]: applications and data are not portable and skills and expertise acquired on a specific system are not reusable with another one. Also, most of the interfaces support a lower level than SQL, with record-at-a-time approaches, which appear to be a step back with respect to relational systems.

the lack of a standard is a great concern for companies interested in adopting any of these systems [7]: applications and data are ex- pensive to convert and competencies and expertise acquired on a specific system get wasted in case of migration. Efforts that support interoperability and translation are definitely needed


\section{Approaches for a common language}
\label{sec:common-language}
The lack of a common standardized language for NoSQL databases, as SQL is for DBMS, has bring industry and developers to build many different solutions with slightly different approaches.

\subsection{SQLifying NoSQL}
A fist approach that is emerging is the \textit{SQLfication} of NoSQL databases.
The main problem here is the inability of industry to switch from DBMS to NoSQL solutions because of the great investments that has been made in the last 30 years both on technologies and skills.
NoSQL vendors started so to create SQL-like wrapper around their NoSQL solutions which offer different features from those of a query language for a traditional relational database, but with a grammar similar to that of SQL.

\noindent For example Google, for Datastore, provides GQL, a SQL-like language for retrieving entities or keys from Datastore.
Other NoSQL database such as Cassandra (with CQL) or OrientDB provides natively such type of SQL-like language support.
There exists some project that has started with this aim.

\subsubsection{Apache Phoenix} 
Apache Phoenix \cite{online:apache-phoenix} aims to become the standard means of accessing HBase data through a well-defined, industry standard API.
Apache Phoenix is a relational database layer over HBase delivered as a client-embedded JDBC driver over HBase data. Apache Phoenix takes standard SQL queries, compiles them into a series of HBase scans, and orchestrates the running of those scans to produce regular JDBC result sets. 

\subsubsection{UnQL}  
Unstructured Data Query Language \cite{online:unql}, or UnQL (pronounced “Uncle”), is a tentative to bring a familiar and standardized data definition and manipulation language to the NoSQL domain. The project was started in 2011 by the joint effort of Couchbase and SQLite.

\noindent The project was stsrted with quite some hype in 2011, but, after some burst of activity, the project came to a hold. So it seems, that at least as a project UNQL has been a failure. 

\subsection{ORM approaches}
ORM (Object Relational Mapping) solutions came into existence to solve OO-impedance mismatching problem. Most popular among them are Hibernate, Toplink, EclipseLink etc. They worked beautifully with relational databases like Oracle and MySQL, among others.

Each ORM solution had its own API and object query language (like HQL for hibernate) which made it difficult for programmers to switch from one framework to another. As a result, efforts were made to make standards and specifications. 

Problem with NoSQL databases is that there is NOT EVEN ONE existing industry standard (like SQL) for them. The very basic idea of “something opposed to SQL”…and as a result – deviation from standards and rules, is going to be suicidal, if not corrected at right time. Learning to work with a new NoSQL database is always cumbersome as a result.

Apart from that, people lack in-depth knowledge of NoSQL. Even if they do, they are confined to one or two. In relational world, people depend upon their knowledge of SQL and JDBC to work on basic and intermediate database things. Switching to another database requires little or almost no effort, which otherwise is painful in NoSQL  world.

ORM for NoSQL is a bit mis-leading term. People prefer to call it “OM tool for NoSQL” or maybe “ODM – Object data-store Mapping tool”. ORM frameworks have already been there for 30+ years and it’s a de-facto industry standard. People are very clear about what ORM tools are supposed to do. There are no surprises.

Key here is to let people forget worrying about complexities inherent in NoSQLs. Let them do things in a way they already know and are comfortable with. Why not use an approach that is there for this problem domain for decades and has proven its usefulness.

A good use case advocating use of ORM tools is migration of applications (built using ORM tool) from RDBMS to NoSQL database. (or even from one NoSQL database to another). This requires (at least in theory) little or no programming effort in business domain.

\subsubsection{Kundera}
Kundera is an opensource project starded by \textbf{Impetus Inc.} an India based tech company active in BigData and Cloud engineering.
Kundera provides a JPA 2.1 compliant object-datastore mapping library for NoSQL datastores leveraging the existing NoSQL database libraries, and builds on top of them a wrapper compliant to the JPA specifications.

\newparagraph The main advantage of the Kundera approach is that, using a well known and defined interface, developers do not need to learn a new framework, furthermore, the use of the JPA interface permits code reusability since each annotated entity and each JPQL query will works independently by the underlying technology actually used.

\subsubsection{Spring-data}
Spring Data \cite{online:spring-data} is a high level \textbf{SpringSource} project whose purpose is to unify and ease the access to different kinds of persistence stores, both relational database systems and NoSQL data stores. Is an umbrella project which contains many sub-projects that are specific to a given database. The database currently supported are the following:
\begin{itemize}
\item JPA
\item MongoDB
\item Redis
\item Neo4j
\item JDBC
\item CouchBase
\item Elasticsearch
\item Cassandra
\item DynamoDB
\end{itemize}

\noindent Framework architecture is reported in figure \ref{fig:spring-data-overview}.

\begin{figure}[tbh]
  \centering
  \includegraphics[width=10cm]{images/spring_data_overview}
  \caption{Architecture of Spring Data \cite{online:spring-data-overview}}
  \label{fig:spring-data-overview}
\end{figure}

\noindent JPA introduced a standard for object/relational mapping (i.e. mapping object graphs to relational database tables), with Spring Data, this support is extended to NoSQL datastores with object-like data structures.
Each type of datastore comes with its own set of annotations to provide the needed meta information for the mapping. An example of such diversity in handling different datastore mapping is reported in the code \ref{code:spring-object-mapping}.

\begin{lstlisting}[language=Java, caption=Spring Data object mapping, label=code:spring-object-mapping]
// MongoDB mapping
@Document(collection="usr")
public class User {
    @Id private String id;
    @Field("fn") private String name;
    private Date lastLogin;
    ...
}

// Neo4j mapping
@NodeEntity
public class User {
    @GraphId Long id;
    private String name;
    private Date lastLogin;
    ...
}
\end{lstlisting}

\noindent When working with data, developers generally write some DAO (Data Access Object) classes that enclose the boiler plate code for CRUD and query operations.
With JPA, CRUD operations are available through the \texttt{EntityManager} interface, queries instead needs various operations: creation, parameter set and execution.
With Spring Data, DAO classes are completely handled by the framework, requiring the user only to provide an interface of the DAO that extends a specific Spring Data repository which will map the operation to the underlying database specific implementation.
An example of this is reported in the code \ref{code:spring-dao}.

\begin{lstlisting}[language=Java, caption=Spring Data repositories, label=code:spring-dao]
public interface UserRepository extends MongoRepository<User, String> {
    List<User> findByName(String name);
    List<User> findByEmail(String email);
}
\end{lstlisting}

\subsubsection{PlayORM}
PlayORM \cite{online:playorm} is an open-source library developed by \textbf{Buffalo Software} with the aim of speeding up developer productivity of developing a NoSQL scalable solution. Currently supports Cassandra, MongoDB and HBase. 

\newparagraph PlayORM takes great inspiration from JPA interface but recognizes that JPA was designed fro DBMS and thus they have re-defined the JPA interface  for NoSQL purposes.
The framework thus make use of the JPA interfaces such as \texttt{EntityManager} for CRUD operations and the \texttt{Query} interface for queries but it re-define all the annotations.
Furthermore it defines an extensions of JPQL called S-JQL which stands for Scalable JQL that adds to JPQL the keyword \texttt{PARTITIONS} that allows the user to specify the specific data partition on which execute the query.

\noindent An example of entity defined with PlayORM is shown in the code snippet \ref{code:playorm-entity} and shows the similarities with the JPA approach.

\begin{lstlisting}[language=Java, caption=PlayORM object mapping, label=code:playorm-entity]
@NoSqlEntity
public class Employee {
    @NoSqlId
    private String id;
    private String lastName;
    @OneToOne
    private Phone phone;
    ...
}
\end{lstlisting}

\subsubsection{SOS Platform}
The SOS (Save Our Systems) Platform \cite{paper:sos-platform} is a academic project developed by Unversita' Roma Tre.

\noindent The platform achieve interoperability among NoSQL databases by defining a common interface  and a meta-layer of abstraction used to maintains entities information. Database specific handlers, read the meta-layer and translate the meta-operations to database-specific operations that are finally performed over the database instance.
The architecture is shown in figure \ref{fig:sos-architecture}.

\begin{figure}[tbh]
  \centering
  \includegraphics[width=9cm]{images/sos_architecture}
  \caption{SOS architecture \cite{paper:sos-platform}}
  \label{fig:sos-architecture}
\end{figure}

\subsubsection{Apache Gora}
Apache Gora \cite{online:apache-gora} born by notice that while excellent ORM frameworks (such as JPA, Apache OpenJPA or Hibernate) exists for relational databases, data modeling in NoSQL data stores, which differ profoundly from their relational cousins, lacks of a similar tool. The aim of the project is to extend the concept of Object Relational Mapping tools (ORM), to introduce Object-to-Datastore Mapping where the underlying technological implementations rely mostly on non-relational data modeling. In essence Gora provides storage abstraction for NoSQL technologies. 
Gora thus gives the user an easy-to-use in-memory data model and persistence for big data framework with data store specific mappings and built in Apache Hadoop support.

\newparagraph The objectives of Gora can be grouped as follows:
\begin{itemize}
\item \textbf{Data Persistence}: persisting objects to Column stores such as Apache HBase, Apache Cassandra, Hypertable; key-value stores such as Voldermort, Redis, etc; SQL databases, such as MySQL, HSQLDB, flat files in local file system of Hadoop HDFS; 
\item \textbf{Data Access}: an easy to use Java-friendly common API for accessing the data regardless of its location; 
\item \textbf{Analysis}: accessing the data and making analysis through adapters for Apache Pig, Apache Hive and Cascading;
\item \textbf{MapReduce support}: out-of-the-box and extensive MapReduce (Apache Hadoop) support for data in the data store.
\end{itemize}

\section{The JPA interface}
\label{sec:jpa}
The Java Persistence API \cite{book:projpa2} was first released as part of Enterprise JavaBeans 3.0 in 2006. As a more general-purpose object-relational mapping facility, it was quickly recognized as such, and was expanded at the request of the community to support use in Java SE environments as well as in the other Java EE container types.

\newparagraph The Java Persistence API provides an object/relational mapping facility to Java developers for managing relational data in Java applications. Java Persistence consists of three areas:
\begin{itemize}
\item the Java Persistence API;
\item object/relational mapping meta-data;
\item the query language.
\end{itemize}

\noindent Mapping meta-data are defined by the user as Java annotations upon the classes that he wants to be mapped to the underlying database.
The user annotated classes represents entities; typically an entity represents a table in a relational database, and each entity instance corresponds to a row in that table. Entities are managed by the entity manager, the EntityManager API creates and removes persistent entity instances, finds entities by the entity’s primary key, and allows queries to be run on entities. 
The \texttt{EntityManager.createQuery} and \texttt{EntityManager.createNamedQuery} methods are used to query the datastore using Java Persistence query language queries. 

\noindent The set of all entity classes managed by the \texttt{EntityManager} instance, is defined by a \textit{peristence unit}.
Persistence units are defined in the \textit{persistence.xml} configuration file, each persistence unit is identified with a name that is unique to the persistence units scope. 

\newparagraph JPA supports two methods for expressing queries to retrieve entities and other persistent data from the database: query languages and the criteria API. The primary query language is Java Persistence Query Language (JPQL), a database-independent query language that operates on the logical entity model as opposed to the physical data model. Queries may also be expressed in SQL to take advantage of the underlying database. The criteria API provides an alternative method for constructing queries based on Java objects instead of query strings.

\noindent JPQL have its roots in the Enterprise JavaBeans Query Language (EJB QL) that was first introduced in the EJB 2.0 specification to allow developers to write portable find and select methods for container-managed entity beans. It was based on a small subset of SQL and it introduced a way to navigate across entity relationships both to select data and to filter the results.
As part of JPA was then introduced JPQL that significantly extends EJB QL, eliminating many weaknesses of its father while preserving backward compatibility.

\section{Cloud Platform Independent Model}
\label{sec:cpim}
Cloud Platform Independent Model \cite{thesis:cpim} is a Java library build in order to make Java developers able to abstract their application logic from the specific Cloud Provider on which the application will actually be deployed.

\newparagraph The aim of CPIM is to overtake the vendor lock-in that affect the current PaaS industry. Each cloud provider define its own API for the services available in the PaaS environment it expose and, even if services are the same among various providers, they expose different API. This locks an application to the PaaS environment it was developed for.

\noindent Since there is no a common interface for such services, if the need of change Cloud Provider arises, maybe due to an increased cost of maintenance, the costs of re-engineer the applciation for the new Cloud provider environment dissolves the benefit of a provider migration.

\section{Summary}
In this chapter has been introduced some of the main reasons that leads to the NoSQL database definition and why industry is so interested in those kind of technology. 
\noindent Has been presented the main projects that have born trying to define a standard NoSQL language or a standard way to communicate with different NoSQL databases, giving a quick overview of the choices made by each one. 
\noindent Finally has been presented an overview of the JPA interface specification and the CPIM library, a more general approach for a common language definition in PaaS environment.
